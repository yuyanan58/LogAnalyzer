
<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<title>John Appleseed — Resume</title>
	<link rel="shortcut icon" href="./avatar.png"/>
	<link rel="apple-touch-icon" href="./yunfan.png"/>
	<link rel="stylesheet" type="text/css" href="yart-main.css">
	<script src="./yart.js"></script>
	<style>
	#source-md {
		display: none;
	}
	</style>
	<script type="text/javascript">
	window.addEventListener('load', function(){
		window.theDoms = document.body.getElementsByClassName('lazy-display-animation');
		window.theDelay = 50;
		for (var i = 0; i < window.theDoms.length; i++) {
			setTimeout((function(ii){
				var _fu = function () {
					window.theDoms[ii].classList.add('played');
				};
				return _fu;
			})(i), window.theDelay*i);
		};
		[].map.call(document.body.getElementsByTagName('a'), function (n) {
			n.target = '_blank';
		});
		[].map.call(document.body.querySelectorAll('img[data-async-src]'), function (n) {
			n.src = n.getAttribute('data-async-src');
		});
	}, false);
	</script>
</head>
<body>
	<div class="download-button-container">	</div>
	<div class="page-start"></div>
	<div id="source-md">
		@ 基于日志的事件挖掘方法研究和应用
		
		# 一、研究目的及课题简介

		针对复杂计算系统的系统管理和优化问题，以计算系统的系统日志数据为研究对象，研究基于日志的事件挖掘方法，重点突破事件提取方法、事件摘要和可视化方法，以及事件挖掘方法等关键技术；进一步地研究上述关键技术的综合实施方法，构建一个事件挖掘试验平台；并以云计算场景下集群系统日志和网络设备日志为应用背景，开展实验验证，优化综合解决方案，为设计更通用的事件挖掘平台奠定基础。
		
		// 研究内容

		1）基于数据挖掘的事件提取方法
		针对日志文件的特点，研究基于聚类方法、或基于分类算法的事件提取方法，设计并实现基于数据挖掘的日志解析器，实现准确的事件提取。
		2）事件摘要及其可视化
		研究一种事件关系网络的事件摘要方法，从事件模式的角度，捕获同类型事件和不同类型事件之间的时序关系；进一步地，为了平衡摘要的准确性和简洁性，研究基于最短描述长度原则的事件摘要优化方法，用于描述庞大复杂的事件日志信息；研究基于事件关系网络的可视化方法，以易于理解的方式帮助系统管理员掌握系统运行状态及其变化。
		3）事件模式挖掘方法研究
		深入分析不同事件模式，如T-pattern，罕见事件模式、事件依赖模式，事件突变等的特点，研究和实现相应的事件模式挖掘方法；设计和实现事件模拟器，用于事件模式挖掘算法验证和分析。


		# 二、文献综述 

		对于计算系统而言，事件表征了系统状态的改变，事件通常包含事件发生的时间戳，产生事件的功能组件，以及更详细的与事件发生相关的信息等。一系列的事件往往以事件流的形式出现，反映出计算系统状态变化的过程。在现实世界中使用的大部分计算系统，如云计算服务系统、企业业务系统、通信系统，智能变电站系统等，均使用日志文件的方式来记录事件流，因此不同类型的计算系统有各种类型的日志，如业务事务日志、传感器日志、计算机系统日志、web访问日志、网络日志等等。这些日志捕获了系统的行为和状态，对于系统管理活动，如采取预防性的维护措施，VM动态迁移以实现负载均衡等有着重要作用。然而，日志文件的数据量通常非常庞大，不同日志文件具有不同的日志格式不尽相同，以文本的形式保留状态变化信息，这些特点使得系统管理员通过人工的方式去理解日志，获取对于管理有用的信息基本上是一个不可能完成的任务。因此，有必要研究一种基于日志的事件挖掘方法，通过审核挖掘得到的事件模式，系统管理员可以建立事件或事故管理规则以消除或者缓解系统失效风险。目前，这种方式已经成为大规模分布式系统管理的标准方法，被IBM和HP这样的IT公司应用于IT基础设施管理，为系统管理员提供可用于系统管理的决策支持，从而达到提升系统资源使用效率、降低系统能耗、提高系统可用性等管理目的。
		在系统管理领域，已有大量的研究工作致力于系统事件挖掘，并且提出了许多用于识别系统异常行为和事件/系统组件之间关系的算法。在这些研究工作中，事件数据往往是离散项或结构化事件的集合，而不是文本日志信息。离散化的或结构化的事件的获取、可视化和分析相对于文本日志信息而言，要容易得多。研究人员已经研发出一些可视化工具包用于宏观地展示一个庞大离散事件集上的系统行为。然而，大多数计算机系统仅生成包含许多细节信息的文本日志。因此，我们需要将文本日志转换成离散化的或结构化的事件。为实现这一目标，我们需要关注一些基于数据挖掘的方法以实现从日志中提取系统事件。
		除了从日志文件中提取事件以外，事件摘要是数据挖掘领域事件挖掘方向相对新的研究热点之一，可以被视为是频繁项集挖掘和频繁场景挖掘的扩展。频繁模式挖掘技术通过识别离散时间之间的相关性，能揭示一些令人感兴趣的模式，往往可以作为事件摘要的构造块。
		现有的大部分事件挖掘研究工作都致力于场景挖掘或频繁模式发现。这些方法简单地产生相互独立的大量模式，而不能提供一种简要的和综合性的事件摘要以揭示数据集所蕴含的系统视图，且这些模式对于系统管理员而言难于获得将它们应用于降低系统运行风险的方法。
		最新的事件挖掘研究工作不在聚焦于频繁模式发现，转而关注事件摘要。通常的方法是将事件序列划分为不相交的事件片段，而后为每一个事件片段产生一个事件模式用于描述片段中的事件。Peng提出了一种事件摘要方法，该方法从通过分析事件日志进而度量事件达到获取模式（W. Peng, C. Perng, T. Li, and H. Wang. Event summarization for system management. In KDD, 2008.）；Kiernan将事件摘要建模成优化问题，主要目的是平衡摘要的准确性和局部模型的缺陷，为此提出了一种基于分片的事件摘要方法，该方法将事件序列按照事件出现的频率变化划分为若干个事件片段（J. Kiernan and E. Terzi. Constructing comprehensive summaries of large event sequences. ACM Transactions on Knowledge Discovery from Data, 3:1–31, 2009）。基于上述工作，Peng进一步地提出了采用隐马尔科夫模型来刻画事件序列片段之间的状态迁移过程，改进基于分片的事件摘要方法（W. Peng, H. Wang, M. Liu, and W. Wang. An algorithmic approach to event summarization. In SIGMOD, 2010.）。然而，这些方法获得的事件摘要对于数据挖掘领域的外行而言难于理解，无法为系统管理员提供足够的帮助。
		综合上述分析，我们可以发现基于日志的事件挖掘方法研究尚需深入研究，以解决日志数据量大、格式复杂、融合困难、准确的摘要和事件模式发现等关键问题。
		参考《数据挖掘：概念与技术》一书，数据分类包括学习阶段(构建分类模型)和分类阶段(使用模型预测给定数据的类标号)。第一阶段，学习阶段，用分类算法分析训练数据。训练集是由数据库元祖和与他们相关联的类标号组成，分类算法通过分析或从训练集“学习”来构造分类器。由于提供了每个训练元祖的类标号，故此阶段也称为监督学习，即分类器的学习在被告知每个训练元祖属于那个类的“监督”下进行的。可以将这一阶段视为学习一个映射或函数，预测给定元祖的类标号。典型的映射用分类规则、决策树或数学公式的形式提供。第二阶段，分类阶段，检验数据用于评估分类规则的准确率，如果准确率可接受，则规则用于新的数据元祖分类。每个检验元祖的类标号与学习模型对该元祖的类预测进行比较，其中正确分类的检验组员所占的百分比即为分类器在给定检验集上的准确率。
		同样参考《数据挖掘：概念与技术》一书，聚类分析是把一个数据对象(或观测)划分成子集的过程。每个子集是一个簇，簇中的对象彼此相似而又区别于其他簇中的对象。划分是通过聚类算法进行的。区别于分类算法，没有提供类标号，聚类分析又称为无监督学习，通过观察学习，而非示例学习。主要的基本聚类算法可以划分为：划分方法、层次方法、基于密度的方法、基于网格的方法


		# 三、任务内容与要求

		// 项目组任务分解
		1）项目总体设计和过程管理 徐彦杰
		2）基于数据挖掘的事件提取方法 徐彦杰负责日志文件解析器的设计、卢云帆负责具体的编码实现，许燕负责实验和测试工作；
		3）事件摘要及其可视化 徐彦杰负责事件摘要模块设计、事件摘要方法研究；卢云帆负责事件摘要方法实现，以及摘要结果可视化方法研究，许燕负责可视化方法实现以及事件摘要模块实验验证和分析；
		4）事件模式挖掘方法研究 徐彦杰负责T-pattern挖掘方法研究、实现和验证；卢云帆负责罕见事件模式、事件突变等模式挖掘方法研究、实现和验证；许燕负责事件依赖模式挖掘方法研究、实现和验证；
		5）事件挖掘试验平台构建 徐彦杰负责总体设计、卢云帆负责集成工作、许燕负责测试和验证

		

		# 四、相关任务详解

		1、日志解析
		对硬件设备产生的日志文件进行解析并存入数据库，可以实现两种程度的解析， 一种具有方法一般性，开发人员对日志本身进行识别，构造相应的识别程序，做到精准程度极高的日志解析。另一种是利用分类聚类的方法，对日志内容进行较为模糊， 精准度差， 但适用面更广的识别。 前一种识别已经用正则表达式， 字符串处理技术解决。 后一种可以通过分类聚类的方法进行宽泛的识别。
		2、事件摘要及其可视化
		在分析事件模式之前，可以通过事件摘要方式从总体角度看看事件之间的关系。
		事件序列在一段时间后会捕获系统和用户活动。之前关于序列挖掘的研究主要集中在探索本地模式，尽管这些模式揭露了本地的关联，但是无法给出整个事件序列的综合概括。另外，我们发现的序列模式的数量很大。因此我们需要一种较好的方式，实现建立简短的概要，在揭示事件之间的本地联系的同时，能够描述整个序列。
		形式上，我们将这种概括问题称为维持概要长度和数据准确性平衡的最优化问题。通过两种动态规划算法的结合，我们可以在多项式时间内解决这个问题。我们还研究了更加有效的贪心算法，并且证明了它适用于大型的数据集。基于人造的数据集和真实的数据集的实验表明，我们的算法是有效的，并且得出来高质量的结果，揭露了数据中的有趣的本地结构。
		最小描述长度原理（Minimum Description Length Principle）有如下表述: 假设P和P’两方想要进行交流，假设P 想要用尽可能少的位把事件序列S发送给P’。为了让P实现最少的交流开销，她想从一系列的模型中选择模型M，用模型M描述她的数据。然后她就能把模型M和在给定传输模型下用来描述数据所需的其它信息发给P’。 因此，P需要对模型M进行编码，并在此前提下对数据编码。我们根据模型和相应数据的总体编码所需的位数来评估所选模型的质量。MDL避免了用小数据开销的复杂模型和大数据开销的简单模型，试着在两个极端之间寻找平衡。很明显MDL是一种一般化的原理，可以由一系列的模型假设实例化。之前已经有过将MDL成功用于各种设置，有决策树分类器，遗传序列建模，几套字符串模式，等等。信息的传递可以转化为，传递模型和模型下描述数据所需的其他信息。因此我们要对事件序列进行概括，可以采用某种模型，对模型进行编码，并在此前提下对数据编码，模型和相应数据的总体编码所需的位数来评估所选模型的质量。
		3、事件模式挖掘方法研究
		通过一些事件挖掘的方法，对事件摘要进行分析，从总体角度获得各个事件之间的联系，挖掘事件序列内隐含的信息，获取在数据中隐藏的信息，用于优化设备的运转。
		事件序列在一段时间后会捕获系统和用户活动。之前关于序列挖掘的研究主要集中在探索本地模式，尽管这些模式揭露了本地的关联，但是无法给出整个事件序列的综合概括。另外，我们发现的序列模式的数量很大，因此我们采取另一种方式，建立简短的概要，在揭示事件之间的本地联系的同时，能够描述整个序列，形式上，我们将这种概括问题称为维持概要长度和数据准确性平衡的最优化问题，而判断概要的优劣程度。
		4、事件挖掘实验平台的构建

		#五、项目预计成果
		
		项目的成果以报告、软件著作权和软件实物方式提供，软件著作权至少1项，软件源代码、可执行程序1份，项目调研报告、技术报告、总结报告1份

		==== A line starting with four equal signs will generate a page break for printing.
	</div>
	<div class="grand cont" id="cont">
	</div>
	<script type="text/javascript">
	var source = document.getElementById('source-md').innerHTML;
	document.getElementById('source-md').remove()
	resumeMarkdownParser(source);
	</script>
</body>
</html>
